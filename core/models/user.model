<?php
/**
 * User model
 *
 * Includes user login, password reset, and permissions logic
 *
 * PHP version 8.4
 *
 *
 * @category   Model
 * @package    Core
 * @author     Arik Savage <ariksavage@gmail.com>
 * @version    1.0
 * @since      2025-01-05
 */

namespace Core\Models;

require_once(__dir__ . '/base.model');
require_once(__dir__ . '/user_role.model');

use \Core\Models\UserRole;

class User extends Base {

  /**
   * Username
   * @var String
   */
  public $username;

  /**
   * Name prefix eg. "Ms.", "Dr.", "Mr."
   * @var String
   */
  public $name_prefix;

  /**
   * First Name
   * @var String
   */
  public $first_name;

  /**
   * Middle Name
   * @var String
   */
  public $middle_name;

  /**
   * Last Name
   * @var String
   */
  public $last_name;

  /**
   * Name Suffix eg. "jr.", "OBE"
   * @var String
   */
  public $name_suffix;

  /**
   * Email address
   * @var String
   */
  public $email;

  /**
   * Password
   * @var String
   */
  protected $password;

  /**
   * Roles
   */
  public $roles;


  /**
   * Construct the model
   *
   * @param string      $label Singular name for this item, eg "User"
   * @param string      $table Database table where this item is stored, eg "users"
   * @param object|null $data  Data to be mapped onto this item
   * @param array       $flags Additional parameters.
   *
   * @return            $this
   */
  public function __construct(object|null $data = null, array $flags = [])
  {
    parent::__construct('User', 'users', $data, $flags = []);
    return $this;
  }


  /**
   * Convert the model to an array for use in a query.
   *
   * And apply any other necessary business logic
   * before saving
   *
   * - Ensure the user's password is hashed, if provided.
   *
   * @return Array
   */
  public function prepareSave() {
    $data = parent::prepareSave();
    if ($this->password) {
      if (strlen($this->password) == 60) { // password is hashed
        $data['password'] = $this->password;
      } else {
        $data['password'] = $this->passwordHash($this->password);
      }
    }
    return $data;
  }

  /**
   * Get the user's full name as a single string:
   *
   * {prefix} {First} {Middle} {Last} {suffix}
   *
   * ignoring any missing segments
   *
   * @return String Full name
   */
  public function name()
  {
    $names = array();
    $names[] = $this->name_prefix;
    $names[] = $this->first_name;
    $names[] = $this->middle_name;
    $names[] = $this->last_name;
    $names = array_filter($names);
    $name = join(' ', $names);
    if ($this->name_suffix) {
      $name .= ', ' . $this->name_suffix;
    }
    return $name;
  }

  /**
   * Validate username and password.
   * if everything matches:
   * Start a new session for the user.
   *
   * @param String $username Username
   * @param String $password Password
   *
   * @return Boolean Login success
   */
  public function login(string $username, string $password)
  {
    $this->byUsername($username);
    if ($this->testPassword($password)) {
      $expiresDays = $this->configValue('session_expires_days');
      return $this->startSession($expiresDays);
    } else {
      $this->error("Access Denied.", 401, "Login");
    }
  }

  /**
   * End the current user's session.
   *
   * @return Boolean Success.
   */
  public function logout()
  {
    $_SESSION['authorization_token'] = NULL;
    $_SESSION['user'] = null;
    return $this->endSession();
  }

  /**
   * Start a new session and generate a link to
   * allow a user to reset their password.
   *
   * @var String $host  Base URL of the request.
   *
   * @return String     Reset Link
   */
  public function passwordResetLink(string $host)
  {
    // end any open sessions
    $now = date('Y-m-d h:i:s');
    $this->update(['date_ended' => $now], 'user_sessions')
    ->where('user_id', '=', $this->id)
    ->and('date_ended', 'IS NULL')
    ->execute();
    // start a new reset session
    $expiresDays = $this->configValue('password_reset_expires_days');
    $token = $this->startSession($expiresDays);
    $link = "{$host}/password-reset/{$token}";
    return $link;
  }

  /**
   * Get user by the current authorization token
   *
   * @return User
   */
  public function byToken()
  {
    $token = $this->getAuthToken();
    $now = date('Y-m-d h:i:s');
    if (!$token) {
      return false;
    }
    $session_q = $this->select(['user_id'], 'user_sessions')->where('token', '=', $token)->and('date_expires', '>', $now)->and('date_ended', 'IS NULL');
    if ($session = $session_q->execute(true)) {
      $q = $this->select()
        ->where('id', '=', $session->user_id);
        if ($data = $q->execute(true)) {
        $this->mapData($data);
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  }

  /**
   * Get a user by their username.
   * @param String $username Username
   *
   * @return User.
   */
  public function byUsername(string $username)
  {
    $q = $this->select()
      ->where('username', '=', $username);
    $data = $q->execute(true);
    if($data) {
      $this->mapData($data);
      return $this;
    } else {
      $this->error("{$username} not found", 404, "User not found");
    }
  }

  /**
   * Test password hash against the password that is provided.
   *
   * Note that password_hash() returns the algorithm,
   * cost and salt as part of the returned hash.
   *
   * Therefore, all information that's needed to verify the hash is included in it.
   * This allows the verify function to verify the hash without needing separate
   * storage for the salt or algorithm information.
   *
   * @param String $password   Un-encrypted password
   *
   * @return Boolean           Password verified
   */
  public function testPassword(string $password)
  {
    $passwordHash = $this->password;
    if (!$passwordHash) {
      return false;
    }
    return password_verify($password, $passwordHash);
  }

  /**
   * Create a hash of the user's password.
   * In this case, we want to increase the default cost for BCRYPT to 12.
   * Note BCRYPT will always be 60 characters.
   *
   * @param String $password   Un-encrypted password
   *
   * @return String            Encrypted password
   */
  protected function passwordHash(string $password)
  {
    $options = [
        'cost' => 12,
    ];
    return password_hash($password, PASSWORD_BCRYPT, $options);
  }

  /**
   * Create a random auth token from the username and current timestamp
   */
  private function generateAuthToken()
  {
    $token = md5($this->username . date('Y-m-d-h-i-s'));
    $_SESSION['authorization_token'] = $token;
    return $token;
  }

  /**
   * Start a new session in the user_sessions table
   * with a new auth token.
   *
   * @return String  Authorization token
   */
  protected function startSession($expiresDays)
  {
    $token = $this->generateAuthToken();
    $data = Array();
    $data['user_id'] = $this->id;
    $data['token'] = $token;
    $data['date_started'] = date('Y-m-d h:i:s');
    $data['date_last_access'] = $data['date_started'];
    $data['date_expires'] = date('Y-m-d h:i:s', strtotime("+{$expiresDays} days"));
    if ($this->insert($data, 'user_sessions')->execute()) {
      $_SESSION['authorization_token'] = $token;
      $_SESSION['user'] = $this;
      return $token;
    } else {
      return false;
    }
  }

  /**
   * Keep the current session alive
   * by updating its last_active value
   *
   * @param String $token  Authorization token matching a session for this user.
   *
   * @return Boolean       Success.
   */
  public function updateSession(string $token = '')
  {
    $token = $this->getAuthToken();
    $data = Array();
    $now = date('Y-m-d h:i:s');
    $data['date_last_access'] = $now; // updated by the table itself
    $expiresDays = $this->configValue('session_expires_days');
    $data['date_expires'] = date('Y-m-d h:i:s', strtotime("+{$expiresDays} days"));
    if ($this->update($data, 'user_sessions')->where('token', '=', $token)->and('user_id', '=', $this->id)->execute()) {
      $this->cleanupSessions();
      return true;
    }
  }

  /**
   * End the current session
   * add the date_ended value to user_sessions
   *
   * @return Boolean  Success
   */
  protected function endSession()
  {
    $token = $this->getAuthToken();
    $data = Array();
    $data['date_ended'] = date('Y-m-d h:i:s');
    return $this->update($data, 'user_sessions')
      ->where('token', '=', $token)
      ->and('user_id', '=', $this->id)
      ->and('date_ended', 'IS NULL')
      ->execute();
  }

  /**
   * End any outstanding sessions
   *
   * @return Boolean  Success
   */
  protected function cleanupSessions()
  {
    $now = date('Y-m-d h:i:s');
    $data = Array('date_ended' => $now);
      return $this->update($data, 'user_sessions')
      ->where('user_id', '=', $this->id)
      ->and('date_expires', '<', $now)
      ->and('date_ended','IS NULL')
      ->execute();
  }

  public function getRoles() {
    $this->roles = $this->select(['user_roles.*'])
      ->from('user_role_assignments')
      ->leftJoin('user_roles', 'role_id', 'id')
      ->where('user_role_assignments.user_id', '=', $this->id)
      ->execute(false, '\Core\Models\UserRole');
  }
}
