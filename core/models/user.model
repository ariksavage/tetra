<?php

namespace Core\Models;

require_once(__dir__ . '/base.model');

class User extends Base {

  /**
   * Username
   * @var String
   */
  public $username;

  /**
   * Name prefix eg. "Ms.", "Dr.", "Mr."
   * @var String
   */
  public $name_prefix;

  /**
   * First Name
   * @var String
   */
  public $first_name;

  /**
   * Middle Name
   * @var String
   */
  public $middle_name;

  /**
   * Last Name
   * @var String
   */
  public $last_name;

  /**
   * Name Suffix eg. "jr.", "OBE"
   * @var String
   */
  public $name_suffix;

  /**
   * Email address
   * @var String
   */
  public $email;

  /**
   * Password
   * @var String
   */
  protected $password;

  public function __construct($data = null, $flags = [])
  {
    parent::__construct('User', 'users', $data, $flags = []);
    return $this;
  }


  public function prepareSave() {
    $data = parent::prepareSave();
    if ($this->password) {
      if (strlen($this->password) == 60) { // password is hashed
        $data['password'] = $this->password;
      } else {
        $data['password'] = $this->passwordHash($this->password);
      }
    }
    return $data;
  }

  public function name()
  {
    $names = array();
    $names[] = $this->name_prefix;
    $names[] = $this->first_name;
    $names[] = $this->middle_name;
    $names[] = $this->last_name;
    $names = array_filter($names);
    $name = join(' ', $names);
    if ($this->name_suffix) {
      $name .= ', ' . $this->name_suffix;
    }
    return $name;
  }

  /**
   * Validate username and password.
   * if everything matches:
   * Start a new session for the user.
   *
   * @param String $username Username
   * @param String $password Password
   *
   * @return Boolean Login success
   */
  public function login($username, $password)
  {
    $this->byUsername($username);
    if ($this->testPassword($password)) {
      return $this->startSession();
    } else {
      $this->error("Access Denied.", 401, "Login");
    }
  }

  /**
   * End the current user's session.
   *
   * @return Boolean Success.
   */
  public function logout()
  {
    $_SESSION['authorization_token'] = NULL;
    $_SESSION['user'] = null;
    return $this->endSession();
  }

  /*
  public function updatePassword($username, $password)
  {
    if ($username !== $this->username) {
      return false;
    }
    $data = [];
    $passwordHash = $this->passwordHash($password);
    $data['password'] = $passwordHash;
    $data['change_password'] = false;
    return $this->update($data)->execute();
  }

  public function passwordResetLink($host, $expDays = 30)
  {
    if ($this->isLoggedIn()) {
      return false;
    }
    $url = $host . '/reset-password';
    $token = $this->updateAuthToken(null, $expDays);
    return $url . '/' . $this->auth_token;
  }
  */

  /**
   * Get user by the current authorization token
   *
   * @return User
   */
  public function byToken()
  {
    $token = $this->getAuthToken();
    $expired = $this->sessionExpires();
    $session_q = $this->select(['user_id'], 'user_sessions')->where('token', '=', $token)->and('date_last_access', '>', $expired);
    if ($session = $session_q->execute(true)) {
      $q = $this->select()
        ->where('id', '=', $session->user_id);
        if ($data = $q->execute(true)) {
        $this->mapData($data);
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  }

  /**
   * Get a user by their username.
   * @param String $username Username
   *
   * @return User.
   */
  public function byUsername($username)
  {
    $q = $this->select()
      ->where('username', '=', $username);
    $data = $q->execute(true);
    if($data) {
      $this->mapData($data);
      return $this;
    } else {
      $this->error("{$username} not found", 404, "User not found");
    }
  }

  /**
   * Test password hash against the password that is provided.
   *
   * Note that password_hash() returns the algorithm,
   * cost and salt as part of the returned hash.
   *
   * Therefore, all information that's needed to verify the hash is included in it.
   * This allows the verify function to verify the hash without needing separate
   * storage for the salt or algorithm information.
   *
   * @param String $password   Un-encrypted password
   *
   * @return Boolean           Password verified
   */
  public function testPassword($password)
  {
    $passwordHash = $this->password;
    if (!$passwordHash) {
      return false;
    }
    return password_verify($password, $passwordHash);
  }

  /**
   * Create a hash of the user's password.
   * In this case, we want to increase the default cost for BCRYPT to 12.
   * Note BCRYPT will always be 60 characters.
   *
   * @param String $password   Un-encrypted password
   *
   * @return String            Encrypted password
   */
  protected function passwordHash($password)
  {
    $options = [
        'cost' => 12,
    ];
    return password_hash($password, PASSWORD_BCRYPT, $options);
  }

  /**
   * Create a random auth token from the username and current timestamp
   */
  private function generateAuthToken()
  {
    $token = md5($this->username . date('Y-m-d-h-i-s'));
    $_SESSION['authorization_token'] = $token;
    return $token;
  }

  /**
   * Get a timestamp of the date that any active sessions have expired.
   *
   * and session_expires = 3 days
   * and today is    2025-01-08 3:00:00
   * Session expires 2025-01-05 3:00:00
   *
   * @return String  Timestamp
   */
  private function sessionExpires()
  {
    $sessionExpiresDays = $this->configValue('session_expires_days');
    $expired = date('Y-m-d h:i:s', strtotime("-{$sessionExpiresDays} day"));
    return $expired;
  }

  /**
   * Start a new session in the user_sessions table
   * with a new auth token.
   *
   * @return String  Authorization token
   */
  protected function startSession()
  {
    $token = $this->generateAuthToken();
    $data = Array();
    $data['user_id'] = $this->id;
    $data['token'] = $token;
    if ($this->insert($data, 'user_sessions')->execute()) {
      $_SESSION['authorization_token'] = $token;
      $_SESSION['user'] = $this;
      $this->updateSession($token);
      return $token;
    } else {
      return false;
    }
  }

  /**
   * Keep the current session alive
   * by updating its last_active value
   *
   * @param String $token  Authorization token matching a session for this user.
   *
   * @return Boolean       Success.
   */
  protected function updateSession($token)
  {
    $token = $this->getAuthToken();
    $data = Array();
    $data['date_last_access'] = null; // updated by the table itself
    if ($this->update($data, 'user_sessions')->where('token', '=', $token)->and('user_id', '=', $this->id)) {
      $this->cleanupSessions();
      return true;
    }
  }

  /**
   * End the current session
   * add the date_ended value to user_sessions
   *
   * @return Boolean  Success
   */
  protected function endSession()
  {
    $token = $this->getAuthToken();
    $data = Array();
    $data['date_ended'] = date('Y-m-d h:i:s');
    return $this->update($data, 'user_sessions')
      ->where('token', '=', $token)
      ->and('user_id', '=', $this->id)
      ->and('date_ended', 'IS NULL')
      ->execute();
  }

  /**
   * End any outstanding sessions
   *
   * @return Boolean  Success
   */
  protected function cleanupSessions()
  {
    $data['date_ended'] = date('Y-m-d h:i:s');
      $expired = $this->sessionExpires();
      return $this->update($data, 'user_sessions')
      ->where('user_id', '=', $this->id)
      ->and('date_last_access', '<', $expired)
      ->and('date_ended','IS NULL')
      ->execute();
  }
}
