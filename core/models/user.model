<?php

namespace Tetra\Models;

require_once(__dir__ . '/base.model');

class User extends Base {

  /**
  * @var String
  * Username
  */
  public $username;

  /**
  * @var String
  * Name prefix eg. "Ms.", "Dr.", "Mr."
  */
  public $name_prefix;

  /**
  * @var String
  * First Name
  */
  public $first_name;

  /**
  * @var String
  * Middle Name
  */
  public $middle_name;

  /**
  * @var String
  * Last Name
  */
  public $last_name;

  /**
  * @var String
  * Name Suffix eg. "jr.", "OBE"
  */
  public $name_suffix;

  /**
  * @var String
  * Email address
  */
  public $email;

  /**
  * @var String
  * assword
  */
  protected $password;

  public function __construct($data = null, $flags = [])
  {
    parent::__construct('User', 'users', $data, $flags = []);
    return $this;
  }

  public function mapData(object $data)
  {
    // if ($data->password && strlen($data->password) !== 60) {
    //   $this->password = $this->passwordHash($data->password);
    //   unset($data->password);
    // }
    return parent::mapData($data);
  }

  public function prepareSave() {
    $data = parent::prepareSave();
    // $this->debug('Prepare Save', $data);
    if ($this->password) {
      if (strlen($this->password) == 60) { // password is hashed
        $data['password'] = $this->password;
      } else {
        $data['password'] = $this->passwordHash($this->password);
      }
    }
    return $data;
  }

  /**
   * Prepare to save.
   * Remove properties that are not reflected in the database
   * 
   * @return Array<Mixed> Array of column => value to be saved.
   */
  // public function beforeSave()
  // {

  //   $data = parent::beforeSave();

  //   if ($this->password && strlen($this->password) !== 60) {
  //     $data['password'] = $this->passwordHash($this->password);
  //   }

  //   if (!$data['username']) {
  //     unset($data['username']);
  //   }
  //   if (!$data['email']) {
  //     unset($data['email']);
  //   }
    
  //   return $data;
  // }

  public function name()
  {
    $names = array();
    $names[] = $this->name_prefix;
    $names[] = $this->first_name;
    $names[] = $this->middle_name;
    $names[] = $this->last_name;
    $names = array_filter($names);
    $name = join(' ', $names);
    if ($this->name_suffix) {
      $name .= ', ' . $this->name_suffix;
    }
    return $name;
  }

  public function login($username, $password)
  {
    $this->byUsername($username);
    if ($this->testPassword($password)) {
      return $this->startSession();
    } else {
      return false;
    }
  }
    /**
   * Test password hash against the password that is provided.
   *
   * Note that password_hash() returns the algorithm,
   * cost and salt as part of the returned hash.
   *
   * Therefore, all information that's needed to verify the hash is included in it.
   * This allows the verify function to verify the hash without needing separate
   * storage for the salt or algorithm information.
   */
  public function testPassword($password)
  {
    $passwordHash = $this->password;
    if (!$passwordHash) {
      return false;
    }
    return password_verify($password, $passwordHash);
  }

  protected function startSession()
  {
    $token = $this->generateAuthToken();
    $data = Array();
    $data['user_id'] = $this->id;
    $data['token'] = $token;
    if ($this->insert($data, 'user_sessions')->execute()) {
      $_SESSION['authorization_token'] = $token;
      $_SESSION['user'] = $this;
      $this->updateSession($token);
      return $token;
    } else {
      return false;
    }
  }

  /**
   * Create a random auth token from the username and current timestamp
   */
  private function generateAuthToken()
  {
    $token = md5($this->username . date('Y-m-d-h-i-s'));
    $_SESSION['token'] = $token;
    return $token;
  }

  protected function updateSession($token)
  {
    $token = $this->getAuthToken();
    $data = Array();
    $data['date_last_access'] = null; // updated by the table itself
    if ($this->update('user_sessions')->set($data)->where('token', '=', $token)->and('user_id', '=', $this->id)) {
      $data['date_ended'] = date('Y-m-d h:i:s');
      $expired = $this->sessionExpires();
      $this->update('user_sessions')
      ->set($data)
      ->where('user_id', '=', $this->id)
      ->and('date_last_access', '<', $expired)
      ->execute();
      return true;
    }
  }

  private function sessionExpires()
  {
    $sessionExpiresDays = $this->configValue('session_expires_days');
    $expired = date('Y-m-d h:i:s', strtotime("-{$sessionExpiresDays} day"));
    return $expired;
  }

    /**
   * Clear the authorization token and
   */
  public function logout()
  {
    $_SESSION['authorization_token'] = NULL;
    $_SESSION['user'] = null;
    return $this->endSession();
  }


  protected function endSession()
  {
    $token = $this->getAuthToken();
    $data = Array();
    $data['date_ended'] = date('Y-m-d h:i:s');
    return $this->update('user_sessions')
          ->set($data)
          ->where('token', '=', $token)
          ->and('user_id', '=', $this->id)
          ->and('date_ended', 'IS NULL')
          ->execute();
  }

  public function passwordResetLink($host, $expDays = 30)
  {
    if ($this->isLoggedIn()) {
      return false;
    }
    $url = $host . '/reset-password';
    $token = $this->updateAuthToken(null, $expDays);
    return $url . '/' . $this->auth_token;
  }

  /**
   * Find the user's authorization token
   * 
   * First check session.
   * Then look in request headers (ie from API calls)
   * 
   * @return String $authToken The Authorization Token.
   */
  private function getAuthToken()
  {
    $authToken = '';
    if(isset($_SESSION['authorization_token'])) {
      return $_SESSION['authorization_token'];
    } else if (isset($_COOKIE['auth'])) {
      $_SESSION['authorization_token'] = $_COOKIE['auth'];
      return $_COOKIE['auth'];
    }
    if (function_exists('apache_request_headers')){
      $headers = \apache_request_headers();
      $authToken = $headers['Authorization'] ?? null;
    }
    if ($authToken){
      $authToken = str_replace('Bearer ', '', $authToken);
      $authToken = trim($authToken);
      $_SESSION['authorization_token'] = $authToken;
      return $authToken;
    }
    return false;
  }

  public function byToken()
  {
    $token = $this->getAuthToken();
    $expired = $this->sessionExpires();
    $session_q = $this->select(['user_id'], 'user_sessions')->where('token', '=', $token)->and('date_last_access', '>', $expired);
    if ($session = $session_q->execute(true)) {
      $q = $this->select()
        ->where('id', '=', $session->user_id);
        if ($data = $q->execute(true)) {
        $this->mapData($data);
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  }

  public function byUsername($username)
  {
    $q = $this->select()
      ->where('username', '=', $username);
    $data = $q->execute(true);
    if($data) {
      $this->parseData($data);
      return $this;
    } else {
      return false;
    }
  }

  // public function loadCurrentUser()
  // {
  //   if(isset($_SESSION['user'])) {
  //     return $_SESSION['user'];
  //   }
  //   if($token = $this->getAuthToken()) {
  //     $q = $this->select()
  //       ->where('auth_token', '=', $token)
  //       ->and()
  //       ->where('auth_expires',  '>=', date('Y-m-d h:i:s', time()));
  //     $data = $q->execute(true);
  //     if($data) {
  //       $this->__construct($data);
  //       $this->getCategory();
  //       $this->getRoles();
  //       $this->getGroups();
  //       $this->access();
  //       $_SESSION['user'] = $this;
  //       return $this;
  //     } else {
  //       return false;
  //     }
  //   }
  // }

  /**
   * Create a hash of the user's password.
   * In this case, we want to increase the default cost for BCRYPT to 12.
   * Note BCRYPT will always be 60 characters.
   */
  protected function passwordHash($password)
  {
    $options = [
        'cost' => 12,
    ];
    return password_hash($password, PASSWORD_BCRYPT, $options);
  }

  public function updatePassword($username, $password)
  {
    if ($username !== $this->username) {
      return false;
    }
    $data = [];
    $passwordHash = $this->passwordHash($password);
    $data['password'] = $passwordHash;
    $data['auth_token'] = '';
    $data['change_password'] = false;
    return $this->update($data)->execute();
  }

  /**
   * Update date_last_accessed to the current date
   * Update auth_expires to the next day.
   */
  // private function access($updateToken = false)
  // {
  //   $expiresDays = 1;
  //   $expires = strtotime("+{$expiresDays} days");
  //   $data = [
  //     'date_last_accessed' => $this->timestamp(),
  //     'auth_expires' => $this->timestamp($expires),
  //   ];
  //   if ($updateToken) {
  //     $this->auth_token = $this->generateAuthToken();
  //     $data['auth_token'] = $this->auth_token;
  //   }
  //   $q = $this->update('user_session')->set($data)->where('id', '=', $this->id);
  //   if ($q->execute()) {
  //     $this->refresh();
  //   }
  //   $_SESSION['authorization_token'] = $this->auth_token;
  //   $_SESSION['user'] = $this;
  //   return $this->auth_token;
  // }
}
